-- XIALIN YAN
-- rt.db;

-- a Create table and import data
CREATE TABLE movies(id integer, name text, score integer);
.mode csv
.import movie-name-score.csv movies
CREATE TABLE moviecast(movie_id integer, cast_id integer, cast_name text);
.import movie-cast.csv moviecast

-- b Build indexes
CREATE INDEX movies_name_index ON movies(name);
CREATE INDEX movies_score_index ON movies(score);

-- c Find average movie score
.headers ON
SELECT AVG(score) AS average_score FROM movies WHERE score >= 1;
SELECT '';

-- d Finding poor films
SELECT id, name, score FROM movies WHERE score > 80 ORDER by score ASC, name ASC LIMIT 5;
SELECT '';

-- e Finding laid back actors (top 5 alphabetically by cast_name)
SELECT cast_id, cast_name, COUNT(cast_name) AS movie_count FROM moviecast GROUP BY cast_name HAVING movie_count=3 ORDER BY cast_name LIMIT 5;
SELECT '';

-- f Aggregate movie scores
SELECT t2.cast_id, t1.cast_name, t2.average_score FROM (SELECT cast_name, cast_id FROM moviecast LEFT JOIN movies ON movies.id = moviecast.movie_id WHERE score >= 1 AND cast_name IN (SELECT cast_name FROM moviecast GROUP BY cast_id) GROUP BY cast_id HAVING count(cast_id) >= 3 ORDER BY cast_name) t1 LEFT JOIN (SELECT cast_id, cast_name, AVG(score) as average_score FROM moviecast LEFT OUTER JOIN movies ON moviecast.movie_id == movies.id WHERE score >= 1 GROUP BY cast_id) t2 ON t1.cast_id = t2.cast_id ORDER by average_score DESC, t1.cast_name ASC LIMIT 10;
SELECT '';

-- g Creating views of actors who are good at collaborating (does not print)
CREATE VIEW good_collaboration AS SELECT t1.sim_cast_id as cast_member_id1, t1.cast_id as cast_member_id2, AVG(score) as average_movie_score, COUNT(*) as movie_count FROM (SELECT a.cast_name as sim_cast_name, a.cast_id as sim_cast_id, a.movie_id, b.cast_name as cast_name, b.cast_id as cast_id FROM moviecast a INNER JOIN moviecast b ON a.movie_id = b.movie_id WHERE a.cast_name != b.cast_name) t1 LEFT JOIN (SELECT score, id FROM movies) t2 ON t1.movie_id = t2.id GROUP BY t1.sim_cast_name, t1.cast_name HAVING movie_count >= 3 AND average_movie_score >= 75 ORDER BY movie_count DESC;
SELECT '';

-- h Best Collaborators: 5 cast members with highest average good_collaboration score
SELECT cast_member_id1 AS cast_id, cast_name, AVG(average_movie_score) AS average_good_collab_score FROM good_collaboration LEFT JOIN moviecast ON cast_member_id1 = cast_id GROUP BY cast_member_id1 ORDER BY average_good_collab_score DESC;
SELECT '';

-- FTS creating table and importing
CREATE VIRTUAL TABLE movie_overview USING fts3(id integer, name text, year integer, overview text, popularity decimal);
.import movie-overview.txt movie_overview

-- i1 Find movies which have best or worst in overview
SELECT COUNT(*) FROM movie_overview WHERE overview MATCH 'best OR worst';
SELECT '';

-- i2 List the ids of the movies that contains the terms “life” and “about” in the overview field with not more than 10 intervening terms in between.
-- order in which the terms appear in the document does not have to be the same as the order in which they appear in the query
SELECT * FROM movie_overview WHERE overview MATCH 'life NEAR about';
SELECT '';
